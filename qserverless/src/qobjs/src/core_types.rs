// Copyright (c) 2021 Quark Container Authors / 2014 The Kubernetes Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::collections::BTreeMap;
use std::time::SystemTime;
use serde::{Deserialize, Serialize};

use crate::selector::{Selector, Labels};
//use serde_json::Result;

// TypeMeta describes an individual object in an API response or request
// with strings representing the type of the object and its API schema version.
// Structures that are versioned or persisted should inline TypeMeta.
//
// +k8s:deepcopy-gen=false
#[derive(Serialize, Deserialize, Debug)]
pub struct TypeMeta {
	// Kind is a string value representing the REST resource this object represents.
	// Servers may infer this from the endpoint the client submits requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	pub kind: String, // `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`

	// APIVersion defines the versioned schema of this representation of an object.
	// Servers should convert recognized schemas to the latest internal value, and
	// may reject unrecognized values.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	// +optional
	pub apiVersion: String, // `json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
#[derive(Serialize, Deserialize, Debug)]
pub struct ObjectMeta {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	// +optional
	pub name: String, // `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`

	// GenerateName is an optional prefix, used by the server, to generate a unique
	// name ONLY IF the Name field has not been provided.
	// If this field is used, the name returned to the client will be different
	// than the name passed. This value will also be combined with a unique suffix.
	// The provided value has the same validation rules as the Name field,
	// and may be truncated by the length of the suffix required to make the value
	// unique on the server.
	//
	// If this field is specified and the generated name exists, the server will return a 409.
	//
	// Applied only if Name is not specified.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
	// +optional
	pub generateName: String, // `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`

	// Namespace defines the space within which each name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	//
	// Must be a DNS_LABEL.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/namespaces
	// +optional
	pub namespace: String, // `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`

	// Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
	// +optional
	pub selfLink: String, // `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`

	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	//
	// Populated by the system.
	// Read-only.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	// +optional
	pub uid: String, // `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID"`

	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	// +optional
	pub resourceVersion: String, // `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`

	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	// +optional
	pub generation: i64, // `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`

	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	//
	// Populated by the system.
	// Read-only.
	// Null for lists.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	pub creationTimestamp: SystemTime, // `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`

	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	pub deletionTimestamp: Option<SystemTime>, // `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`

	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	// +optional
	pub deletionGracePeriodSeconds: Option<i64>, // `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	pub labels: BTreeMap<String, String>, // `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	pub annotations: BTreeMap<String, String>, // `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`

	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	// +optional
	// +patchMergeKey=uid
	// +patchStrategy=merge
	pub ownerReferences: Vec<OwnerReference>, // `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`

	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	// Finalizers may be processed and removed in any order.  Order is NOT enforced
	// because it introduces significant risk of stuck finalizers.
	// finalizers is a shared field, any actor with permission can reorder it.
	// If the finalizer list is processed in order, then this can lead to a situation
	// in which the component responsible for the first finalizer in the list is
	// waiting for a signal (field value, external system, or other) produced by a
	// component responsible for a finalizer later in the list, resulting in a deadlock.
	// Without enforced ordering finalizers are free to order amongst themselves and
	// are not vulnerable to ordering changes in the list.
	// +optional
	// +patchStrategy=merge
	pub finalizers: Vec<String>, // `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`

	// Tombstone: ClusterName was a legacy field that was always cleared by
	// the system and never used.
	// ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`

	// ManagedFields maps workflow-id and version to the set of fields
	// that are managed by that workflow. This is mostly for internal
	// housekeeping, and users typically shouldn't need to set or
	// understand this field. A workflow can be the user's name, a
	// controller's name, or the name of a specific apply path like
	// "ci-cd". The set of fields is always in the version that the
	// workflow used when modifying the object.
	//
	// +optional
	//managedFields: Vec<ManagedFieldsEntry>, // `json:"managedFields,omitempty" protobuf:"bytes,17,rep,name=managedFields"`
}

// OwnerReference contains enough information to let you identify an owning
// object. An owning object must be in the same namespace as the dependent, or
// be cluster-scoped, so there is no namespace field.
// +structType=atomic
#[derive(Serialize, Deserialize, Debug)]
pub struct OwnerReference {
	// API version of the referent.
	apiVersion: String, // `json:"apiVersion" protobuf:"bytes,5,opt,name=apiVersion"`
	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: String, // `json:"kind" protobuf:"bytes,1,opt,name=kind"`
	// Name of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	name: String, // `json:"name" protobuf:"bytes,3,opt,name=name"`
	// UID of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	uid: String, // `json:"uid" protobuf:"bytes,4,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
	// If true, this reference points to the managing controller.
	// +optional
	controller: Option<bool>, // `json:"controller,omitempty" protobuf:"varint,6,opt,name=controller"`
	// If true, AND if the owner has the "foregroundDeletion" finalizer, then
	// the owner cannot be deleted from the key-value store until this
	// reference is removed.
	// See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
	// for how the garbage collector interacts with this field and enforces the foreground deletion.
	// Defaults to false.
	// To set this field, a user needs "delete" permission of the owner,
	// otherwise 422 (Unprocessable Entity) will be returned.
	// +optional
	blockOwnerDeletion: Option<bool>, // `json:"blockOwnerDeletion,omitempty" protobuf:"varint,7,opt,name=blockOwnerDeletion"`
}

#[derive(Serialize, Deserialize, Debug)]
pub enum Quantity {
    #[serde(rename = "DecimalExponent")]
    DecimalExponent(f64),
    #[serde(rename = "BinarySI")]
    BinarySI(i64),
    #[serde(rename = "DecimalSI")]
    DecimalSI(String),
}

// StorageMedium defines ways that storage can be allocated to a volume.
#[derive(Serialize, Deserialize, Debug)]
pub enum StorageMedium {
    #[serde(rename = "")]
    StorageMediumDefault, //         use whatever the default is for the node, assume anything we don't explicitly handle is this
	#[serde(rename = "Memory")]
    StorageMediumMemory, //          use memory (e.g. tmpfs on linux)
	#[serde(rename = "HugePages")]
    StorageMediumHugePages, //       use hugepages
	#[serde(rename = "HugePages")]
    StorageMediumHugePagesPrefix, // prefix for full medium notation HugePages-<size>
}

// Protocol defines network protocols supported for things like container ports.
#[derive(Serialize, Deserialize, Debug)]
pub enum Protocol {
    // ProtocolTCP is the TCP protocol.
	#[serde(rename = "TCP")]
    ProtocolTCP,
	// ProtocolUDP is the UDP protocol.
	#[serde(rename = "UDP")]
    ProtocolUDP, 
	// ProtocolSCTP is the SCTP protocol.
	#[serde(rename = "SCTP")]
    ProtocolSCTP, 
}

impl Default for Protocol {
    fn default() -> Self {
        return Self::ProtocolTCP;
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerPort {
    // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
	// named port in a pod must have a unique name. Name for the port that can be
	// referred to by services.
	// +optional
    #[serde(default, skip_serializing_if = "String::is_empty")]
	pub name: String, // string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
	// Number of port to expose on the host.
	// If specified, this must be a valid port number, 0 < x < 65536.
	// If HostNetwork is specified, this must match ContainerPort.
	// Most containers do not need this.
	// +optional
    #[serde(default)]
	pub hostPort: i32, // int32 `json:"hostPort,omitempty" protobuf:"varint,2,opt,name=hostPort"`
	// Number of port to expose on the pod's IP address.
	// This must be a valid port number, 0 < x < 65536.
    pub containerPort: i32, // int32 `json:"containerPort" protobuf:"varint,3,opt,name=containerPort"`
	// Protocol for port. Must be UDP, TCP, or SCTP.
	// Defaults to "TCP".
	// +optional
	// +default="TCP"
    #[serde(default)]
	pub protocol: Protocol, // `json:"protocol,omitempty" protobuf:"bytes,4,opt,name=protocol,casttype=Protocol"`
	// What host IP to bind the external port to.
	// +optional
    #[serde(default)]
	pub hostIP: String, // `json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`
}

#[derive(Serialize, Deserialize, Debug)]
pub struct EnvVar {
    // Name of the environment variable. Must be a C_IDENTIFIER.
	pub name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`

	// Optional: no more than one of the following may be specified.

	// Variable references $(VAR_NAME) are expanded
	// using the previously defined environment variables in the container and
	// any service environment variables. If a variable cannot be resolved,
	// the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
	// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
	// Escaped references will never be expanded, regardless of whether the variable
	// exists or not.
	// Defaults to "".
	// +optional
    #[serde(default, skip_serializing_if = "String::is_empty")]
	pub value: String, // `json:"value,omitempty" protobuf:"bytes,2,opt,name=value"`
	// Source for the environment variable's value. Cannot be used if value is not empty.
	// +optional

    #[serde(skip_serializing_if = "Option::is_none")]
	pub valueFrom: Option<EnvVarSource>, // `json:"valueFrom,omitempty" protobuf:"bytes,3,opt,name=valueFrom"`
}

#[derive(Serialize, Deserialize, Debug)]
pub struct EnvVarSource {
	// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
	// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
	FieldRef: Option<ObjectFieldSelector>, // `json:"fieldRef,omitempty" protobuf:"bytes,1,opt,name=fieldRef"`
	// Selects a resource of the container: only resources limits and requests
	// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
	ResourceFieldRef: Option<ObjectFieldSelector>, // `json:"resourceFieldRef,omitempty" protobuf:"bytes,2,opt,name=resourceFieldRef"`
	// Selects a key of a ConfigMap.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
	ConfigMapKeyRef: Option<ConfigMapKeySelector>, // `json:"configMapKeyRef,omitempty" protobuf:"bytes,3,opt,name=configMapKeyRef"`
	// Selects a key of a secret in the pod's namespace
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
	SecretKeyRef: Option<SecretKeySelector>, //  `json:"secretKeyRef,omitempty" protobuf:"bytes,4,opt,name=secretKeyRef"`

}

// ObjectFieldSelector selects an APIVersioned field of an object.
#[derive(Serialize, Deserialize, Debug)]
pub struct ObjectFieldSelector {
    // Version of the schema the FieldPath is written in terms of, defaults to "v1".
	// +optional
    #[serde(default, skip_serializing_if = "String::is_empty")]
	apiVersion: String, // `json:"apiVersion,omitempty" protobuf:"bytes,1,opt,name=apiVersion"`
	// Path of the field to select in the specified API version.
	fieldPath: String,// `json:"fieldPath" protobuf:"bytes,2,opt,name=fieldPath"`
}


// Selects a key from a ConfigMap.
// +structType=atomic
#[derive(Serialize, Deserialize, Debug)]
pub struct ConfigMapKeySelector {
	// The ConfigMap to select from.
	localObjectReference: LocalObjectReference, // `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
	// The key to select.
	key: String, // `json:"key" protobuf:"bytes,2,opt,name=key"`
	// Specify whether the ConfigMap or its key must be defined
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
	optional: Option<bool>, // `json:"optional,omitempty" protobuf:"varint,3,opt,name=optional"`
}

// SecretKeySelector selects a key of a Secret.
// +structType=atomic
#[derive(Serialize, Deserialize, Debug)]
pub struct SecretKeySelector  {
	// The name of the secret in the pod's namespace to select from.
	localObjectReference: LocalObjectReference, // `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
	// The key of the secret to select from.  Must be a valid secret key.
	key: String, // `json:"key" protobuf:"bytes,2,opt,name=key"`
	// Specify whether the Secret or its key must be defined
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    optional: Option<bool>, // `json:"optional,omitempty" protobuf:"varint,3,opt,name=optional"`
}

// EnvFromSource represents the source of a set of ConfigMaps
#[derive(Serialize, Deserialize, Debug)]
pub struct  EnvFromSource {
	// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	prefix: String, // `json:"prefix,omitempty" protobuf:"bytes,1,opt,name=prefix"`
	// The ConfigMap to select from
	// +optional
	configMapRef: Option<ConfigMapEnvSource>, // `json:"configMapRef,omitempty" protobuf:"bytes,2,opt,name=configMapRef"`
	// The Secret to select from
	// +optional
	SecretRef: Option<SecretEnvSource>, // `json:"secretRef,omitempty" protobuf:"bytes,3,opt,name=secretRef"`
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment
// variables with.
//
// The contents of the target ConfigMap's Data field will represent the
// key-value pairs as environment variables.
#[derive(Serialize, Deserialize, Debug)]
pub struct ConfigMapEnvSource {
	// The ConfigMap to select from.
	localObjectReference: LocalObjectReference, // `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
	// Specify whether the ConfigMap must be defined
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    optional:  Option<bool>, // `json:"optional,omitempty" protobuf:"varint,2,opt,name=optional"`
}

// SecretEnvSource selects a Secret to populate the environment
// variables with.
//
// The contents of the target Secret's Data field will represent the
// key-value pairs as environment variables.
#[derive(Serialize, Deserialize, Debug)]
pub struct SecretEnvSource {
	// The Secret to select from.
	localObjectReference: LocalObjectReference, // `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
	// Specify whether the Secret must be defined
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    optional:  Option<bool>, // `json:"optional,omitempty" protobuf:"varint,2,opt,name=optional"`
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
// +structType=atomic
#[derive(Serialize, Deserialize, Debug)]
pub struct LocalObjectReference {
	// Name of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	name: String, // `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
}

// HTTPHeader describes a custom header to be used in HTTP probes
#[derive(Serialize, Deserialize, Debug)]
pub struct HTTPHeader {
	// The header field name
	name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`
	// The header field value
	value: String, // `json:"value" protobuf:"bytes,2,opt,name=value"`
}

// HTTPGetAction describes an action based on HTTP Get requests.
#[derive(Serialize, Deserialize, Debug)]
pub struct HTTPGetAction {
	// Path to access on the HTTP server.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	pub path: String, // `json:"path,omitempty" protobuf:"bytes,1,opt,name=path"`
	// Name or number of the port to access on the container.
	// Number must be in the range 1 to 65535.
	// Name must be an IANA_SVC_NAME.
	pub port: String, //intstr.IntOrString `json:"port" protobuf:"bytes,2,opt,name=port"`
	// Host name to connect to, defaults to the pod IP. You probably want to set
	// "Host" in httpHeaders instead.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	pub host: String, // `json:"host,omitempty" protobuf:"bytes,3,opt,name=host"`
	// Scheme to use for connecting to the host.
	// Defaults to HTTP.
	// +optional
	pub scheme: URIScheme, // `json:"scheme,omitempty" protobuf:"bytes,4,opt,name=scheme,casttype=URIScheme"`
	// Custom headers to set in the request. HTTP allows repeated headers.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub HTTPHeaders: Vec<HTTPHeader> // `json:"httpHeaders,omitempty" protobuf:"bytes,5,rep,name=httpHeaders"`
}

// URIScheme identifies the scheme used for connection to a host for Get actions
// +enum
#[derive(Serialize, Deserialize, Debug)]
pub enum URIScheme {
    // URISchemeHTTP means that the scheme used will be http://
    #[serde(rename = "HTTP")]
	URISchemeHTTP, 
	// URISchemeHTTPS means that the scheme used will be https://
	#[serde(rename = "HTTPS")]
	URISchemeHTTPS,
}

// TCPSocketAction describes an action based on opening a socket
#[derive(Serialize, Deserialize, Debug)]
pub struct TCPSocketAction {
	// Number or name of the port to access on the container.
	// Number must be in the range 1 to 65535.
	// Name must be an IANA_SVC_NAME.
	port: i32, // intstr.IntOrString `json:"port" protobuf:"bytes,1,opt,name=port"`
	// Optional: Host name to connect to, defaults to the pod IP.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	host: String, // `json:"host,omitempty" protobuf:"bytes,2,opt,name=host"`
}

#[derive(Serialize, Deserialize, Debug)]
pub struct GRPCAction {
	// Port number of the gRPC service. Number must be in the range 1 to 65535.
	port: i32, // `json:"port" protobuf:"bytes,1,opt,name=port"`

	// Service is the name of the service to place in the gRPC HealthCheckRequest
	// (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
	//
	// If this is not specified, the default behavior is defined by gRPC.
	// +optional
	// +default=""
	#[serde(default, skip_serializing_if = "String::is_empty")]
	service: String, // `json:"service" protobuf:"bytes,2,opt,name=service"`
}

// ExecAction describes a "run in container" action.
#[derive(Serialize, Deserialize, Debug)]
pub struct ExecAction {
	// Command is the command line to execute inside the container, the working directory for the
	// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
	// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
	// a shell, you need to explicitly call out to that shell.
	// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	pub command: Vec<String>, // `json:"command,omitempty" protobuf:"bytes,1,rep,name=command"`
}

// Probe describes a health check to be performed against a container to determine whether it is
// alive or ready to receive traffic.
#[derive(Serialize, Deserialize, Debug)]
pub struct  Probe {
	// The action taken to determine the health of a container
	pub handler: ProbeHandler, // `json:",inline" protobuf:"bytes,1,opt,name=handler"`
	// Number of seconds after the container has started before liveness probes are initiated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	#[serde(default)]
	pub initialDelaySeconds: i32, // `json:"initialDelaySeconds,omitempty" protobuf:"varint,2,opt,name=initialDelaySeconds"`
	// Number of seconds after which the probe times out.
	// Defaults to 1 second. Minimum value is 1.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	#[serde(default)]
	pub timeoutSeconds: i32, // int32 `json:"timeoutSeconds,omitempty" protobuf:"varint,3,opt,name=timeoutSeconds"`
	// How often (in seconds) to perform the probe.
	// Default to 10 seconds. Minimum value is 1.
	// +optional
	#[serde(default)]
	pub periodSeconds: i32, // `json:"periodSeconds,omitempty" protobuf:"varint,4,opt,name=periodSeconds"`
	// Minimum consecutive successes for the probe to be considered successful after having failed.
	// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
	// +optional
	#[serde(default)]
	pub successThreshold: i32, // int32 `json:"successThreshold,omitempty" protobuf:"varint,5,opt,name=successThreshold"`
	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	// Defaults to 3. Minimum value is 1.
	// +optional
	#[serde(default)]
	pub failureThreshold: i32, // int32 `json:"failureThreshold,omitempty" protobuf:"varint,6,opt,name=failureThreshold"`
	// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
	// value overrides the value provided by the pod spec.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down).
	// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
	// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub terminationGracePeriodSeconds: Option<i64>, // *int64 `json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,7,opt,name=terminationGracePeriodSeconds"`
}

// PullPolicy describes a policy for if/when to pull a container image
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
pub enum PullPolicy {
    // PullAlways means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
	#[serde(rename = "Always")]
    PullAlways,
	// PullNever means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
	#[serde(rename = "Never")]
    PullNever,
	// PullIfNotPresent means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
	#[serde(rename = "IfNotPresent")]
    PullIfNotPresent,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum PreemptionPolicy {
    // PreemptLowerPriority means that pod can preempt other pods with lower priority.
	#[serde(rename = "PreemptLowerPriority")]
    PreemptLowerPriority,
	// PreemptNever means that pod never preempts other pods with lower priority.
	#[serde(rename = "Never")]
    PreemptNever,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum TerminationMessagePolicy {
    // TerminationMessageReadFile is the default behavior and will set the container status message to
	// the contents of the container's terminationMessagePath when the container exits.
	#[serde(rename = "File")]
    TerminationMessageReadFile,
	// TerminationMessageFallbackToLogsOnError will read the most recent contents of the container logs
	// for the container status message when the container exits with an error and the
	// terminationMessagePath has no contents.
	#[serde(rename = "FallbackToLogsOnError")]
    TerminationMessageFallbackToLogsOnError,
}

// Capability represent POSIX capabilities type
pub type Capability = String;

// Adds and removes POSIX capabilities from running containers.
#[derive(Serialize, Deserialize, Debug)]
pub struct Capabilities {
	// Added capabilities
	// +optional
	add: Vec<Capability>, // `json:"add,omitempty" protobuf:"bytes,1,rep,name=add,casttype=Capability"`
	// Removed capabilities
	// +optional
	#[serde(skip_serializing_if = "Vec::is_empty")]
    drop: Vec<Capability>, // `json:"drop,omitempty" protobuf:"bytes,2,rep,name=drop,casttype=Capability"`
}

// ResourceRequirements describes the compute resource requirements.
#[derive(Serialize, Deserialize, Debug)]
pub struct ResourceRequirements {
    // Limits describes the maximum amount of compute resources allowed.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	#[serde(skip_serializing_if = "BTreeMap::is_empty")]
    limits: ResourceList, // `json:"limits,omitempty" protobuf:"bytes,1,rep,name=limits,casttype=ResourceList,castkey=ResourceName"`
	// Requests describes the minimum amount of compute resources required.
	// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
	// otherwise to an implementation-defined value. Requests cannot exceed Limits.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	#[serde(skip_serializing_if = "BTreeMap::is_empty")]
    requests: ResourceList, // `json:"requests,omitempty" protobuf:"bytes,2,rep,name=requests,casttype=ResourceList,castkey=ResourceName"`
	// Claims lists the names of resources, defined in spec.resourceClaims,
	// that are used by this container.
	//
	// This is an alpha field and requires enabling the
	// DynamicResourceAllocation feature gate.
	//
	// This field is immutable.
	//
	// +listType=map
	// +listMapKey=name
	// +featureGate=DynamicResourceAllocation
	// +optional
	#[serde(skip_serializing_if = "Vec::is_empty")]
    claims: Vec<ResourceClaim>, // `json:"claims,omitempty" protobuf:"bytes,3,opt,name=claims"`
}

// TerminationMessagePathDefault means the default path to capture the application termination message running in a container
pub const TERMINATION_MESSAGE_PATH_DEFAULT: &str = "/dev/termination-log";

// A single application container that you want to run within a pod.
#[derive(Serialize, Deserialize, Debug)]
pub struct Container {
    // Name of the container specified as a DNS_LABEL.
	// Each container in a pod must have a unique name (DNS_LABEL).
	// Cannot be updated.
	pub name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`
	// Container image name.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// This field is optional to allow higher level config management to default or override
	// container images in workload controllers like Deployments and StatefulSets.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    pub image: String, // `json:"image,omitempty" protobuf:"bytes,2,opt,name=image"`
	// Entrypoint array. Not executed within a shell.
	// The container image's ENTRYPOINT is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub command: Vec<String>, // `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
	// Arguments to the entrypoint.
	// The container image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub args: Vec<String>, // `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
	// Container's working directory.
	// If not specified, the container runtime's default will be used, which
	// might be configured in the container image.
	// Cannot be updated.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    pub workingDir: String, // `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
	// List of ports to expose from the container. Not specifying a port here
	// DOES NOT prevent that port from being exposed. Any port which is
	// listening on the default "0.0.0.0" address inside a container will be
	// accessible from the network.
	// Modifying this array with strategic merge patch may corrupt the data.
	// For more information See https://github.com/kubernetes/kubernetes/issues/108255.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=containerPort
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=containerPort
	// +listMapKey=protocol
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ports: Vec<ContainerPort>, // `json:"ports,omitempty" patchStrategy:"merge" patchMergeKey:"containerPort" protobuf:"bytes,6,rep,name=ports"`
	// List of sources to populate environment variables in the container.
	// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
	// will be reported as an event when the container is starting. When a key exists in multiple
	// sources, the value associated with the last source will take precedence.
	// Values defined by an Env with a duplicate key will take precedence.
	// Cannot be updated.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub envFrom: Vec<EnvFromSource>, // `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
	// List of environment variables to set in the container.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub env: Vec<EnvVar>, // `json:"env,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,7,rep,name=env"`
	// Compute Resources required by this container.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<ResourceRequirements>, // `json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`
	// Pod volumes to mount into the container's filesystem.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=mountPath
	// +patchStrategy=merge
	//VolumeMounts []VolumeMount `json:"volumeMounts,omitempty" patchStrategy:"merge" patchMergeKey:"mountPath" protobuf:"bytes,9,rep,name=volumeMounts"`
	// volumeDevices is the list of block devices to be used by the container.
	// +patchMergeKey=devicePath
	// +patchStrategy=merge
	// +optional
	//VolumeDevices []VolumeDevice `json:"volumeDevices,omitempty" patchStrategy:"merge" patchMergeKey:"devicePath" protobuf:"bytes,21,rep,name=volumeDevices"`
	// Periodic probe of container liveness.
	// Container will be restarted if the probe fails.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub livenessProbe: Option<Probe>, // `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
	// Periodic probe of container service readiness.
	// Container will be removed from service endpoints if the probe fails.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub readinessProbe: Option<Probe>, // `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`
	// StartupProbe indicates that the Pod has successfully initialized.
	// If specified, no other probes are executed until this completes successfully.
	// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
	// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
	// when it might take a long time to load data or warm a cache, than during steady-state operation.
	// This cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub startupProbe: Option<Probe>, // `json:"startupProbe,omitempty" protobuf:"bytes,22,opt,name=startupProbe"`
	// Actions that the management system should take in response to container lifecycle events.
	// Cannot be updated.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<Lifecycle>, // `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
	// Optional: Path at which the file to which the container's termination message
	// will be written is mounted into the container's filesystem.
	// Message written is intended to be brief final status, such as an assertion failure message.
	// Will be truncated by the node if greater than 4096 bytes. The total message length across
	// all containers will be limited to 12kb.
	// Defaults to /dev/termination-log.
	// Cannot be updated.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    pub terminationMessagePath: String, // `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
	// Indicate how the termination message should be populated. File will use the contents of
	// terminationMessagePath to populate the container status message on both success and failure.
	// FallbackToLogsOnError will use the last chunk of container log output if the termination
	// message file is empty and the container exited with an error.
	// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
	// Defaults to File.
	// Cannot be updated.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub terminationMessagePolicy: Option<TerminationMessagePolicy>, // `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
	// Image pull policy.
	// One of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    pub imagePullPolicy: Option<PullPolicy>, // `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
	// SecurityContext defines the security options the container should be run with.
	// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
	// +optional
	//SecurityContext *SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`

	// Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
	// and shouldn't be used for general purpose containers.

	// Whether this container should allocate a buffer for stdin in the container runtime. If this
	// is not set, reads from stdin in the container will always result in EOF.
	// Default is false.
	// +optional
	#[serde(default)]
    pub stdin: bool, // `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
	// Whether the container runtime should close the stdin channel after it has been opened by
	// a single attach. When stdin is true the stdin stream will remain open across multiple attach
	// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
	// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
	// at which time stdin is closed and remains closed until the container is restarted. If this
	// flag is false, a container processes that reads from stdin will never receive an EOF.
	// Default is false
	// +optional
	#[serde(default)]
    pub stdinOnce: bool, // `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
	// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
	// Default is false.
	// +optional
	#[serde(default)]
    pub tty: bool, // `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`

    // If set, the name of the container from PodSpec that this ephemeral container targets.
	// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
	// If not set then the ephemeral container uses the namespaces configured in the Pod spec.
	//
	// The container runtime must implement support for this feature. If the runtime does not
	// support namespace targeting then the result of setting this field is undefined.
	// +optional

    // used for EphemeralContainer
    #[serde(default)]
	pub TargetContainerName: Option<String>,
}

// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Debug)]
pub struct ResourceClaim {
    // Name must match the name of one entry in pod.spec.resourceClaims of
	// the Pod where this field is used. It makes that resource available
	// inside a container.
	name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`
}

// ProbeHandler defines a specific action that should be taken in a probe.
// One and only one of the fields must be specified.
#[derive(Serialize, Deserialize, Debug)]
pub struct ProbeHandler {
    // Exec specifies the action to take.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    exec: Option<ExecAction>, // `json:"exec,omitempty" protobuf:"bytes,1,opt,name=exec"`
	// HTTPGet specifies the http request to perform.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    httpGet: Option<HTTPGetAction>, // `json:"httpGet,omitempty" protobuf:"bytes,2,opt,name=httpGet"`
	// TCPSocket specifies an action involving a TCP port.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    tcpSocket: Option<TCPSocketAction>, // `json:"tcpSocket,omitempty" protobuf:"bytes,3,opt,name=tcpSocket"`

	// GRPC specifies an action involving a GRPC port.
	// This is a beta field and requires enabling GRPCContainerProbe feature gate.
	// +featureGate=GRPCContainerProbe
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    grpc: Option<GRPCAction>, // `json:"grpc,omitempty" protobuf:"bytes,4,opt,name=grpc"`
}

// LifecycleHandler defines a specific action that should be taken in a lifecycle
// hook. One and only one of the fields, except TCPSocket must be specified.
#[derive(Serialize, Deserialize, Debug)]
pub struct LifecycleHandler {
    // Exec specifies the action to take.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub exec: Option<ExecAction>, // `json:"exec,omitempty" protobuf:"bytes,1,opt,name=exec"`
	// HTTPGet specifies the http request to perform.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub httpGet: Option<HTTPGetAction>, // `json:"httpGet,omitempty" protobuf:"bytes,2,opt,name=httpGet"`
	// TCPSocket specifies an action involving a TCP port.
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub tcpSocket: Option<TCPSocketAction>, // `json:"tcpSocket,omitempty" protobuf:"bytes,3,opt,name=tcpSocket"`
}

// Lifecycle describes actions that the management system should take in response to container lifecycle
// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
// until the action is complete, unless the container process fails, in which case the handler is aborted.
#[derive(Serialize, Deserialize, Debug)]
pub struct Lifecycle {
    // PostStart is called immediately after a container is created. If the handler fails,
	// the container is terminated and restarted according to its restart policy.
	// Other management of the container blocks until the hook completes.
	// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub postStart: Option<LifecycleHandler>, // `json:"postStart,omitempty" protobuf:"bytes,1,opt,name=postStart"`
	// PreStop is called immediately before a container is terminated due to an
	// API request or management event such as liveness/startup probe failure,
	// preemption, resource contention, etc. The handler is not called if the
	// container crashes or exits. The Pod's termination grace period countdown begins before the
	// PreStop hook is executed. Regardless of the outcome of the handler, the
	// container will eventually terminate within the Pod's termination grace
	// period (unless delayed by finalizers). Other management of the container blocks until the hook completes
	// or until the termination grace period is reached.
	// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
	// +optional
	#[serde(skip_serializing_if = "Option::is_none")]
    pub preStop: Option<LifecycleHandler>, // `json:"preStop,omitempty" protobuf:"bytes,2,opt,name=preStop"`
}

// These are valid condition statuses. "ConditionTrue" means a resource is in the condition.
// "ConditionFalse" means a resource is not in the condition. "ConditionUnknown" means kubernetes
// can't decide if a resource is in the condition or not. In the future, we could add other
// intermediate conditions, e.g. ConditionDegraded.
#[derive(Serialize, Deserialize, Debug)]
pub enum ConditionStatus {
    #[serde(rename = "True")]
    ConditionTrue,
	#[serde(rename = "False")]
    ConditionFalse,
	#[serde(rename = "Unknown")]
    ConditionUnknown,
}


// ContainerStateWaiting is a waiting state of a container.
#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerStateWaiting {
    // (brief) reason the container is not yet running.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    reason: String, //`json:"reason,omitempty" protobuf:"bytes,1,opt,name=reason"`
	// Message regarding why the container is not yet running.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    message: String, // `json:"message,omitempty" protobuf:"bytes,2,opt,name=message"`
}

// ContainerStateRunning is a running state of a container.
#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerStateRunning {
    // Time at which the container was last (re-)started
	// +optional
	startedAt: SystemTime, // `json:"startedAt,omitempty" protobuf:"bytes,1,opt,name=startedAt"`
}

// ContainerStateTerminated is a terminated state of a container.
#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerStateTerminated {
    // Exit status from the last termination of the container
	exitCode: i32, // `json:"exitCode" protobuf:"varint,1,opt,name=exitCode"`
	// Signal from the last termination of the container
	// +optional
	#[serde(default)]
    signal: i32, // `json:"signal,omitempty" protobuf:"varint,2,opt,name=signal"`
	// (brief) reason from the last termination of the container
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    resone: String, // `json:"reason,omitempty" protobuf:"bytes,3,opt,name=reason"`
	// Message regarding the last termination of the container
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    message: String, // `json:"message,omitempty" protobuf:"bytes,4,opt,name=message"`
	// Time at which previous execution of the container started
	// +optional
	startedAt: SystemTime, // `json:"startedAt,omitempty" protobuf:"bytes,5,opt,name=startedAt"`
	// Time at which the container last terminated
	// +optional
	finishedAt: SystemTime, // `json:"finishedAt,omitempty" protobuf:"bytes,6,opt,name=finishedAt"`
	// Container's ID in the format '<type>://<container_id>'
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
    containerID: String, // `json:"containerID,omitempty" protobuf:"bytes,7,opt,name=containerID"`
}

// ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
#[derive(Serialize, Deserialize, Debug)]
pub enum ContainerState {
	// Details about a waiting container
	// +optional
	#[serde(rename = "waiting")]
    Waiting(ContainerStateWaiting), // `json:"waiting,omitempty" protobuf:"bytes,1,opt,name=waiting"`
	// Details about a running container
	// +optional
	#[serde(rename = "running")]
    Running(ContainerStateRunning), // `json:"running,omitempty" protobuf:"bytes,2,opt,name=running"`
	// Details about a terminated container
	// +optional
	#[serde(rename = "terminated")]
    Terminated(ContainerStateTerminated), // `json:"terminated,omitempty" protobuf:"bytes,3,opt,name=terminated"`
}

// ContainerStatus contains details for the current status of this container.
#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerStatus {
    // This must be a DNS_LABEL. Each container in a pod must have a unique name.
	// Cannot be updated.
	name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`
	// Details about the container's current condition.
	// +optional
	state: ContainerState, // `json:"state,omitempty" protobuf:"bytes,2,opt,name=state"`
	// Details about the container's last termination condition.
	// +optional
	lastTerminationState: ContainerState, // `json:"lastState,omitempty" protobuf:"bytes,3,opt,name=lastState"`
	// Specifies whether the container has passed its readiness probe.
	ready: bool, // `json:"ready" protobuf:"varint,4,opt,name=ready"`
	// The number of times the container has been restarted.
	restartCount: i32, // `json:"restartCount" protobuf:"varint,5,opt,name=restartCount"`
	// The image the container is running.
	// More info: https://kubernetes.io/docs/concepts/containers/images.
	image: String, // `json:"image" protobuf:"bytes,6,opt,name=image"`
	// ImageID of the container's image.
	imageID: String, // `json:"imageID" protobuf:"bytes,7,opt,name=imageID"`
	// Container's ID in the format '<type>://<container_id>'.
	// +optional
	containerID: String, // `json:"containerID,omitempty" protobuf:"bytes,8,opt,name=containerID"`
	// Specifies whether the container has passed its startup probe.
	// Initialized as false, becomes true after startupProbe is considered successful.
	// Resets to false when the container is restarted, or if kubelet loses state temporarily.
	// Is always true when no startupProbe is defined.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
    started: Option<bool>, // `json:"started,omitempty" protobuf:"varint,9,opt,name=started"`
}

// PodPhase is a label for the condition of a pod at the current time.
#[derive(Serialize, Deserialize, Debug)]
pub enum PodPhase {
    // PodPending means the pod has been accepted by the system, but one or more of the containers
	// has not been started. This includes time before being bound to a node, as well as time spent
	// pulling images onto the host.
	#[serde(rename = "Pending")]
    PodPending,
    // PodRunning means the pod has been bound to a node and all of the containers have been started.
	// At least one container is still running or is in the process of being restarted.
	#[serde(rename = "Running")]
    PodRunning,
    // PodSucceeded means that all containers in the pod have voluntarily terminated
	// with a container exit code of 0, and the system is not going to restart any of these containers.
	#[serde(rename = "Succeeded")]
    PodSucceeded,
    // PodFailed means that all containers in the pod have terminated, and at least one container has
	// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
	#[serde(rename = "Failed")]
    PodFailed,
    // PodUnknown means that for some reason the state of the pod could not be obtained, typically due
	// to an error in communicating with the host of the pod.
	// Deprecated: It isn't being set since 2015 (74da3b14b0c0f658b3bb8d2def5094686d0e9095)
	#[serde(rename = "Unknown")]
    PodUnknown,
}

impl Default for PodPhase {
	fn default() -> Self {
		return Self::PodPending;
	}
}

// PodConditionType is a valid value for PodCondition.Type
#[derive(Serialize, Deserialize, Debug)]
pub enum PodConditionType {
    // ContainersReady indicates whether all containers in the pod are ready.
	#[serde(rename = "ContainersReady")]
    ContainersReady, 
	// PodInitialized means that all init containers in the pod have started successfully.
	#[serde(rename = "Initialized")]
    PodInitialized, 
	// PodReady means the pod is able to service requests and should be added to the
	// load balancing pools of all matching services.
	#[serde(rename = "Ready")]
    PodReady, 
	// PodScheduled represents status of the scheduling process for this pod.
	#[serde(rename = "PodScheduled")]
    PodScheduled, 
	// DisruptionTarget indicates the pod is about to be terminated due to a
	// disruption (such as preemption, eviction API or garbage-collection).
	#[serde(rename = "DisruptionTarget")]
    DisruptionTarget, 
}

#[derive(Serialize, Deserialize, Debug)]
pub enum PodScheduleState {
	// PodReasonUnschedulable reason in PodScheduled PodCondition means that the scheduler
	// can't schedule the pod right now, for example due to insufficient resources in the cluster.
	#[serde(rename = "Unschedulable")]
    PodReasonUnschedulable,

	// PodReasonSchedulingGated reason in PodScheduled PodCondition means that the scheduler
	// skips scheduling the pod because one or more scheduling gates are still present.
	#[serde(rename = "SchedulingGated")]
    PodReasonSchedulingGated,

	// PodReasonSchedulerError reason in PodScheduled PodCondition means that some internal error happens
	// during scheduling, for example due to nodeAffinity parsing errors.
	#[serde(rename = "SchedulerError")]
    PodReasonSchedulerError,

	// TerminationByKubelet reason in DisruptionTarget pod condition indicates that the termination
	// is initiated by kubelet
	#[serde(rename = "TerminationByKubelet")]
    PodReasonTerminationByKubelet,

	// PodReasonPreemptionByScheduler reason in DisruptionTarget pod condition indicates that the
	// disruption was initiated by scheduler's preemption.
	#[serde(rename = "PreemptionByScheduler")]
    PodReasonPreemptionByScheduler,
}

// PodCondition contains details for the current condition of this pod.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodCondition {
    // Type is the type of the condition.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	#[serde(rename = "type")]
    type_: PodConditionType, // `json:"type" protobuf:"bytes,1,opt,name=type,casttype=PodConditionType"`
	// Status is the status of the condition.
	// Can be True, False, Unknown.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	status: ConditionStatus, // `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
	// Last time we probed the condition.
	// +optional
	lastProbeTime: SystemTime, // `json:"lastProbeTime,omitempty" protobuf:"bytes,3,opt,name=lastProbeTime"`
	// Last time the condition transitioned from one status to another.
	// +optional
	lastTransitionTime: SystemTime, // `json:"lastTransitionTime,omitempty" protobuf:"bytes,4,opt,name=lastTransitionTime"`
	// Unique, one-word, CamelCase reason for the condition's last transition.
	// +optional
	reason: String, // `json:"reason,omitempty" protobuf:"bytes,5,opt,name=reason"`
	// Human-readable message indicating details about last transition.
	// +optional
	message: String, // `json:"message,omitempty" protobuf:"bytes,6,opt,name=message"`
}

// RestartPolicy describes how the container should be restarted.
// Only one of the following restart policies may be specified.
// If none of the following policies is specified, the default one
// is RestartPolicyAlways.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum RestartPolicy {
    #[serde(rename = "Always")]
    RestartPolicyAlways,
	#[serde(rename = "OnFailure")]
    RestartPolicyOnFailure,
	#[serde(rename = "Never")]
    RestartPolicyNever,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum DNSPolicy {
	// DNSClusterFirstWithHostNet indicates that the pod should use cluster DNS
	// first, if it is available, then fall back on the default
	// (as determined by kubelet) DNS settings.
	#[serde(rename = "ClusterFirstWithHostNet")]
    DNSClusterFirstWithHostNet,

	// DNSClusterFirst indicates that the pod should use cluster DNS
	// first unless hostNetwork is true, if it is available, then
	// fall back on the default (as determined by kubelet) DNS settings.
	#[serde(rename = "ClusterFirst")]
    DNSClusterFirst,

	// DNSDefault indicates that the pod should use the default (as
	// determined by kubelet) DNS settings.
	#[serde(rename = "Default")]
    DNSDefault,

	// DNSNone indicates that the pod should use empty DNS settings. DNS
	// parameters such as nameservers and search paths should be defined via
	// DNSConfig.
	#[serde(rename = "None")]
    DNSNone,
}

// DefaultTerminationGracePeriodSeconds indicates the default duration in
	// seconds a pod needs to terminate gracefully.
pub const DEFAULT_TERMINATION_GRACE_PERIOD_SECONDS : usize = 30;

// A node selector represents the union of the results of one or more label queries
// over a set of nodes; that is, it represents the OR of the selectors represented
// by the node selector terms.
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct NodeSelector {
	// Required. A list of node selector terms. The terms are ORed.
	nodeSelectorTerms: Vec<NodeSelectorTerm>, // `json:"nodeSelectorTerms" protobuf:"bytes,1,rep,name=nodeSelectorTerms"`
}

// Node affinity is a group of node affinity scheduling rules.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeAffinity {
    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// will try to eventually evict the pod from its node.
	// +optional
	// RequiredDuringSchedulingRequiredDuringExecution *NodeSelector `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`

	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	// +optional
	requiredDuringSchedulingIgnoredDuringExecution: NodeSelector,  // `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,opt,name=requiredDuringSchedulingIgnoredDuringExecution"`
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	// +optional
	preferredDuringSchedulingIgnoredDuringExecution: Vec<PreferredSchedulingTerm>, // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
#[derive(Serialize, Deserialize, Debug)]
pub struct PreferredSchedulingTerm {
    // Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	weight: i32, // `json:"weight" protobuf:"varint,1,opt,name=weight"`
	// A node selector term, associated with the corresponding weight.
	preference: NodeSelectorTerm, // `json:"preference" protobuf:"bytes,2,opt,name=preference"`
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct NodeSelectorTerm {
	// A list of node selector requirements by node's labels.
	// +optional
	matchExpressions: Vec<NodeSelectorRequirement>, // `json:"matchExpressions,omitempty" protobuf:"bytes,1,rep,name=matchExpressions"`
	// A list of node selector requirements by node's fields.
	// +optional
	matchFields: Vec<NodeSelectorRequirement>, // `json:"matchFields,omitempty" protobuf:"bytes,2,rep,name=matchFields"`
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeSelectorRequirement {
    // The label key that the selector applies to.
	key: String, // `json:"key" protobuf:"bytes,1,opt,name=key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	operator: NodeSelectorOperator, // `json:"operator" protobuf:"bytes,2,opt,name=operator,casttype=NodeSelectorOperator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	// +optional
	values: Vec<String>, // `json:"values,omitempty" protobuf:"bytes,3,rep,name=values"`
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum NodeSelectorOperator {
	#[serde(rename = "In")]
    NodeSelectorOpIn,
	#[serde(rename = "NotIn")]
    NodeSelectorOpNotIn,
	#[serde(rename = "Exists")]
    NodeSelectorOpExists,
	#[serde(rename = "DoesNotExist")]
    NodeSelectorOpDoesNotExist,
	#[serde(rename = "Gt")]
    NodeSelectorOpGt,
	#[serde(rename = "Lt")]
    NodeSelectorOpLt,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TopologySelectorTerm {
    // Usage: Fields of type []TopologySelectorTerm must be listType=atomic.

	// A list of topology selector requirements by labels.
	// +optional
	matchLabelExpressions: Vec<TopologySelectorLabelRequirement>, // `json:"matchLabelExpressions,omitempty" protobuf:"bytes,1,rep,name=matchLabelExpressions"`
}

// A topology selector requirement is a selector that matches given label.
// This is an alpha feature and may change in the future.
#[derive(Serialize, Deserialize, Debug)]
pub struct TopologySelectorLabelRequirement {
	// The label key that the selector applies to.
	key: String, // `json:"key" protobuf:"bytes,1,opt,name=key"`
	// An array of string values. One value must match the label to be selected.
	// Each entry in Values is ORed.
	values: Vec<String>, // `json:"values" protobuf:"bytes,2,rep,name=values"`
}

// Affinity is a group of affinity scheduling rules.
#[derive(Serialize, Deserialize, Debug)]
pub enum Affinity {
    // Describes node affinity scheduling rules for the pod.
	// +optional
    #[serde(rename = "nodeAffinity")]
	NodeAffinity(NodeAffinity), // `json:"nodeAffinity,omitempty" protobuf:"bytes,1,opt,name=nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	// +optional
	#[serde(rename = "podAffinity")]
    PodAffinity(PodAffinity), // `json:"podAffinity,omitempty" protobuf:"bytes,2,opt,name=podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	// +optional
    #[serde(rename = "podAntiAffinity")]
	PodAntiAffinity(PodAntiAffinity), // `json:"podAntiAffinity,omitempty" protobuf:"bytes,3,opt,name=podAntiAffinity"`

}

// Pod affinity is a group of inter pod affinity scheduling rules.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodAffinity {
	// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system will try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +optional
	// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`

	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +optional
	requiredDuringSchedulingIgnoredDuringExecution: Vec<PodAffinityTerm>, // `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	// +optional
	preferredDuringSchedulingIgnoredDuringExecution: Vec<WeightedPodAffinityTerm>, // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
}

// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodAntiAffinity {
    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system will try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +optional
	// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`

	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	// +optional
	requiredDuringSchedulingIgnoredDuringExecution: Vec<PodAffinityTerm>, //  `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	// +optional
	preferredDuringSchedulingIgnoredDuringExecution: Vec<WeightedPodAffinityTerm>, // `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
#[derive(Serialize, Deserialize, Debug)]
pub struct WeightedPodAffinityTerm {
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	weight: i32, // `json:"weight" protobuf:"varint,1,opt,name=weight"`
	// Required. A pod affinity term, associated with the corresponding weight.
	podAffinityTerm: PodAffinityTerm, // `json:"podAffinityTerm" protobuf:"bytes,2,opt,name=podAffinityTerm"`

}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
#[derive(Serialize, Deserialize, Debug)]
pub struct PodAffinityTerm {
	// A label query over a set of resources, in this case pods.
	// +optional
	labelSelector: Selector, // `json:"labelSelector,omitempty" protobuf:"bytes,1,opt,name=labelSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	// +optional
	namespaces: Vec<String>, // `json:"namespaces,omitempty" protobuf:"bytes,2,rep,name=namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	topologyKey: String, // `json:"topologyKey" protobuf:"bytes,3,opt,name=topologyKey"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	// +optional
	namespaceSelector: Selector, // `json:"namespaceSelector,omitempty" protobuf:"bytes,4,opt,name=namespaceSelector"`
}

// The node this Taint is attached to has the "effect" on
// any pod that does not tolerate the Taint.
#[derive(Serialize, Deserialize, Debug)]
pub struct Taint {
    // Required. The taint key to be applied to a node.
	key: String, // `json:"key" protobuf:"bytes,1,opt,name=key"`
	// The taint value corresponding to the taint key.
	// +optional
	value: String, // `json:"value,omitempty" protobuf:"bytes,2,opt,name=value"`
	// Required. The effect of the taint on pods
	// that do not tolerate the taint.
	// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	effect: TaintEffect, // `json:"effect" protobuf:"bytes,3,opt,name=effect,casttype=TaintEffect"`
	// TimeAdded represents the time at which the taint was added.
	// It is only written for NoExecute taints.
	// +optional
	timeAdded: SystemTime, // `json:"timeAdded,omitempty" protobuf:"bytes,4,opt,name=timeAdded"`
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum TaintEffect {
    // Do not allow new pods to schedule onto the node unless they tolerate the taint,
	// but allow all pods submitted to Kubelet without going through the scheduler
	// to start, and allow all already-running pods to continue running.
	// Enforced by the scheduler.
	#[serde(rename = "NoSchedule")]
    TaintEffectNoSchedule,
	// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
	// new pods onto the node, rather than prohibiting new pods from scheduling
	// onto the node entirely. Enforced by the scheduler.
	#[serde(rename = "PreferNoSchedule")]
    TaintEffectPreferNoSchedule,
	// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
	// Like TaintEffectNoSchedule, but additionally do not allow pods submitted to
	// Kubelet without going through the scheduler to start.
	// Enforced by Kubelet and the scheduler.
	// TaintEffectNoScheduleNoAdmit TaintEffect = "NoScheduleNoAdmit"

	// Evict any already-running pods that do not tolerate the taint.
	// Currently enforced by NodeController.
	#[serde(rename = "NoExecute")]
    TaintEffectNoExecute,
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
#[derive(Serialize, Deserialize, Debug)]
pub struct Toleration {
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	// +optional
	key: String, // `json:"key,omitempty" protobuf:"bytes,1,opt,name=key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	// +optional
	operator: TolerationOperator, // `json:"operator,omitempty" protobuf:"bytes,2,opt,name=operator,casttype=TolerationOperator"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	// +optional
	value: String, // `json:"value,omitempty" protobuf:"bytes,3,opt,name=value"`
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	// +optional
	effect: TaintEffect, // `json:"effect,omitempty" protobuf:"bytes,4,opt,name=effect,casttype=TaintEffect"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	// +optional
	#[serde(default)]
    tolerationSeconds: Option<i64>,// `json:"tolerationSeconds,omitempty" protobuf:"varint,5,opt,name=tolerationSeconds"`
}

// A toleration operator is the set of operators that can be used in a toleration.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum TolerationOperator {
    #[serde(rename = "Exists")]
    TolerationOpExists, 
	#[serde(rename = "Equal")]
    TolerationOpEqual, 
}

// PodReadinessGate contains the reference to a pod condition
#[derive(Serialize, Deserialize, Debug)]
pub struct PodReadinessGate {
    // ConditionType refers to a condition in the pod's condition list with matching type.
    conditionType: PodConditionType, // `json:"conditionType" protobuf:"bytes,1,opt,name=conditionType,casttype=PodConditionType"`
}

// PodSpec is a description of a pod.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodSpec {
    // List of volumes that can be mounted by containers belonging to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge,retainKeys
	//Volumes []Volume `json:"volumes,omitempty" patchStrategy:"merge,retainKeys" patchMergeKey:"name" protobuf:"bytes,1,rep,name=volumes"`
	// List of initialization containers belonging to the pod.
	// Init containers are executed in order prior to containers being started. If any
	// init container fails, the pod is considered to have failed and is handled according
	// to its restartPolicy. The name for an init container or normal container must be
	// unique among all containers.
	// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
	// The resourceRequirements of an init container are taken into account during scheduling
	// by finding the highest request/limit for each resource type, and then using the max of
	// of that value or the sum of the normal containers. Limits are applied to init containers
	// in a similar fashion.
	// Init containers cannot currently be added or removed.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +patchMergeKey=name
	// +patchStrategy=merge
	initContainers: Vec<Container>, // `json:"initContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,20,rep,name=initContainers"`
	// List of containers belonging to the pod.
	// Containers cannot currently be added or removed.
	// There must be at least one container in a Pod.
	// Cannot be updated.
	// +patchMergeKey=name
	// +patchStrategy=merge
	containers: Vec<Container>, // `json:"containers" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=containers"`
	// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
	// pod to perform user-initiated actions such as debugging. This list cannot be specified when
	// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
	// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	ephemeralContainers: Vec<EphemeralContainer>, // `json:"ephemeralContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,34,rep,name=ephemeralContainers"`
	// Restart policy for all containers within the pod.
	// One of Always, OnFailure, Never.
	// Default to Always.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	restartPolicy: Option<RestartPolicy>, // `json:"restartPolicy,omitempty" protobuf:"bytes,3,opt,name=restartPolicy,casttype=RestartPolicy"`
	// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down).
	// If this value is nil, the default grace period will be used instead.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	// Defaults to 30 seconds.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	terminationGracePeriodSeconds: Option<i64>, // `json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,4,opt,name=terminationGracePeriodSeconds"`
	// Optional duration in seconds the pod may be active on the node relative to
	// StartTime before the system will actively try to mark it failed and kill associated containers.
	// Value must be a positive integer.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	activeDeadlineSeconds: Option<i64>, // `json:"activeDeadlineSeconds,omitempty" protobuf:"varint,5,opt,name=activeDeadlineSeconds"`
	// Set DNS policy for the pod.
	// Defaults to "ClusterFirst".
	// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
	// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
	// To have DNS options set along with hostNetwork, you have to specify DNS policy
	// explicitly to 'ClusterFirstWithHostNet'.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	dnsPolicy: Option<DNSPolicy>, // `json:"dnsPolicy,omitempty" protobuf:"bytes,6,opt,name=dnsPolicy,casttype=DNSPolicy"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	// +mapType=atomic
	nodeSelector: BTreeMap<String, String>, // `json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`

	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	serviceAccountName: String, // `json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`
	
    // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
	// +optional
	automountServiceAccountToken: Option<bool>, // `json:"automountServiceAccountToken,omitempty" protobuf:"varint,21,opt,name=automountServiceAccountToken"`

	// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
	// the scheduler simply schedules this pod onto that node, assuming that it fits resource
	// requirements.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	nodeName: String, // `json:"nodeName,omitempty" protobuf:"bytes,10,opt,name=nodeName"`
	// Host networking requested for this pod. Use the host's network namespace.
	// If this option is set, the ports that will be used must be specified.
	// Default to false.
	// +k8s:conversion-gen=false
	// +optional
	#[serde(default)]
	hostNetwork: bool, // `json:"hostNetwork,omitempty" protobuf:"varint,11,opt,name=hostNetwork"`
	// Use the host's pid namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	#[serde(default)]
	hostPID: bool, // `json:"hostPID,omitempty" protobuf:"varint,12,opt,name=hostPID"`
	// Use the host's ipc namespace.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	#[serde(default)]
	hostIPC: bool, // `json:"hostIPC,omitempty" protobuf:"varint,13,opt,name=hostIPC"`
	// Share a single process namespace between all of the containers in a pod.
	// When this is set containers will be able to view and signal processes from other containers
	// in the same pod, and the first process in each container will not be assigned PID 1.
	// HostPID and ShareProcessNamespace cannot both be set.
	// Optional: Default to false.
	// +k8s:conversion-gen=false
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	shareProcessNamespace: Option<bool>, // `json:"shareProcessNamespace,omitempty" protobuf:"varint,27,opt,name=shareProcessNamespace"`
	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	//SecurityContext *PodSecurityContext `json:"securityContext,omitempty" protobuf:"bytes,14,opt,name=securityContext"`
	// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
	// If specified, these secrets will be passed to individual puller implementations for them to use.
	// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	imagePullSecrets: Vec<LocalObjectReference>, // `json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,15,rep,name=imagePullSecrets"`
	// Specifies the hostname of the Pod
	// If not specified, the pod's hostname will be set to a system-defined value.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	hostname: String, // `json:"hostname,omitempty" protobuf:"bytes,16,opt,name=hostname"`
	// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
	// If not specified, the pod will not have a domainname at all.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	subdomain: String, // `json:"subdomain,omitempty" protobuf:"bytes,17,opt,name=subdomain"`
	// If specified, the pod's scheduling constraints
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	affinity: Option<Affinity>, // `json:"affinity,omitempty" protobuf:"bytes,18,opt,name=affinity"`
	// If specified, the pod will be dispatched by specified scheduler.
	// If not specified, the pod will be dispatched by default scheduler.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	schedulerName: String, // `json:"schedulerName,omitempty" protobuf:"bytes,19,opt,name=schedulerName"`
	// If specified, the pod's tolerations.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	tolerations: Vec<Toleration>, // `json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`
	// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
	// file if specified. This is only valid for non-hostNetwork pods.
	// +optional
	// +patchMergeKey=ip
	// +patchStrategy=merge
	hostAliases: Vec<HostAlias>, // `json:"hostAliases,omitempty" patchStrategy:"merge" patchMergeKey:"ip" protobuf:"bytes,23,rep,name=hostAliases"`
	// If specified, indicates the pod's priority. "system-node-critical" and
	// "system-cluster-critical" are two special keywords which indicate the
	// highest priorities with the former being the highest priority. Any other
	// name must be defined by creating a PriorityClass object with that name.
	// If not specified, the pod priority will be default or zero if there is no
	// default.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	priorityClassName: String, // `json:"priorityClassName,omitempty" protobuf:"bytes,24,opt,name=priorityClassName"`
	// The priority value. Various system components use this field to find the
	// priority of the pod. When Priority Admission Controller is enabled, it
	// prevents users from setting this field. The admission controller populates
	// this field from PriorityClassName.
	// The higher the value, the higher the priority.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	priority: Option<i32>, // `json:"priority,omitempty" protobuf:"bytes,25,opt,name=priority"`
	// Specifies the DNS parameters of a pod.
	// Parameters specified here will be merged to the generated DNS
	// configuration based on DNSPolicy.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	dnsConfig: Option<PodDNSConfig>, // `json:"dnsConfig,omitempty" protobuf:"bytes,26,opt,name=dnsConfig"`
	// If specified, all readiness gates will be evaluated for pod readiness.
	// A pod is ready when all its containers are ready AND
	// all conditions specified in the readiness gates have status equal to "True"
	// More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	readinessGates: Vec<PodReadinessGate>, // `json:"readinessGates,omitempty" protobuf:"bytes,28,opt,name=readinessGates"`
	// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
	// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
	// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
	// empty definition that uses the default runtime handler.
	// More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	runtimeClassName: String, // `json:"runtimeClassName,omitempty" protobuf:"bytes,29,opt,name=runtimeClassName"`
	// EnableServiceLinks indicates whether information about services should be injected into pod's
	// environment variables, matching the syntax of Docker links.
	// Optional: Defaults to true.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	enableServiceLinks: Option<bool>, // `json:"enableServiceLinks,omitempty" protobuf:"varint,30,opt,name=enableServiceLinks"`
	// PreemptionPolicy is the Policy for preempting pods with lower priority.
	// One of Never, PreemptLowerPriority.
	// Defaults to PreemptLowerPriority if unset.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	preemptionPolicy: Option<PreemptionPolicy>,  // `json:"preemptionPolicy,omitempty" protobuf:"bytes,31,opt,name=preemptionPolicy"`
	// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
	// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
	// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
	// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
	// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
	// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
	// More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
	// +optional
	#[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
	overhead: ResourceList, // `json:"overhead,omitempty" protobuf:"bytes,32,opt,name=overhead"`
	// TopologySpreadConstraints describes how a group of pods ought to spread across topology
	// domains. Scheduler will schedule pods in a way which abides by the constraints.
	// All topologySpreadConstraints are ANDed.
	// +optional
	// +patchMergeKey=topologyKey
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=topologyKey
	// +listMapKey=whenUnsatisfiable
	topologySpreadConstraints: Vec<TopologySpreadConstraint>, // `json:"topologySpreadConstraints,omitempty" patchStrategy:"merge" patchMergeKey:"topologyKey" protobuf:"bytes,33,opt,name=topologySpreadConstraints"`
	// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
	// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
	// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
	// If a pod does not have FQDN, this has no effect.
	// Default to false.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	setHostnameAsFQDN: Option<bool>, // `json:"setHostnameAsFQDN,omitempty" protobuf:"varint,35,opt,name=setHostnameAsFQDN"`
	// Specifies the OS of the containers in the pod.
	// Some pod and container fields are restricted if this is set.
	//
	// If the OS field is set to linux, the following fields must be unset:
	// -securityContext.windowsOptions
	//
	// If the OS field is set to windows, following fields must be unset:
	// - spec.hostPID
	// - spec.hostIPC
	// - spec.hostUsers
	// - spec.securityContext.seLinuxOptions
	// - spec.securityContext.seccompProfile
	// - spec.securityContext.fsGroup
	// - spec.securityContext.fsGroupChangePolicy
	// - spec.securityContext.sysctls
	// - spec.shareProcessNamespace
	// - spec.securityContext.runAsUser
	// - spec.securityContext.runAsGroup
	// - spec.securityContext.supplementalGroups
	// - spec.containers[*].securityContext.seLinuxOptions
	// - spec.containers[*].securityContext.seccompProfile
	// - spec.containers[*].securityContext.capabilities
	// - spec.containers[*].securityContext.readOnlyRootFilesystem
	// - spec.containers[*].securityContext.privileged
	// - spec.containers[*].securityContext.allowPrivilegeEscalation
	// - spec.containers[*].securityContext.procMount
	// - spec.containers[*].securityContext.runAsUser
	// - spec.containers[*].securityContext.runAsGroup
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	os: Option<PodOS>, // `json:"os,omitempty" protobuf:"bytes,36,opt,name=os"`

	// Use the host's user namespace.
	// Optional: Default to true.
	// If set to true or not present, the pod will be run in the host user namespace, useful
	// for when the pod needs a feature only available to the host user namespace, such as
	// loading a kernel module with CAP_SYS_MODULE.
	// When set to false, a new userns is created for the pod. Setting false is useful for
	// mitigating container breakout vulnerabilities even allowing users to run their
	// containers as root without actually having root privileges on the host.
	// This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
	// +k8s:conversion-gen=false
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	hostUsers: Option<bool>, // `json:"hostUsers,omitempty" protobuf:"bytes,37,opt,name=hostUsers"`

	// SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
	// More info:  https://git.k8s.io/enhancements/keps/sig-scheduling/3521-pod-scheduling-readiness.
	//
	// This is an alpha-level feature enabled by PodSchedulingReadiness feature gate.
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	schedulingGates: Vec<PodSchedulingGate>, // `json:"schedulingGates,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,38,opt,name=schedulingGates"`
	// ResourceClaims defines which ResourceClaims must be allocated
	// and reserved before the Pod is allowed to start. The resources
	// will be made available to those containers which consume them
	// by name.
	//
	// This is an alpha field and requires enabling the
	// DynamicResourceAllocation feature gate.
	//
	// This field is immutable.
	//
	// +patchMergeKey=name
	// +patchStrategy=merge,retainKeys
	// +listType=map
	// +listMapKey=name
	// +featureGate=DynamicResourceAllocation
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	resourceClaims: Vec<PodResourceClaim>, // `json:"resourceClaims,omitempty" patchStrategy:"merge,retainKeys" patchMergeKey:"name" protobuf:"bytes,39,rep,name=resourceClaims"`
}

// PodResourceClaim references exactly one ResourceClaim through a ClaimSource.
// It adds a name to it that uniquely identifies the ResourceClaim inside the Pod.
// Containers that need access to the ResourceClaim reference it with this name.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodResourceClaim {
    // Name uniquely identifies this resource claim inside the pod.
	// This must be a DNS_LABEL.
	name: String, //`json:"name" protobuf:"bytes,1,name=name"`

	// Source describes where to find the ResourceClaim.
	source: ClaimSource, // `json:"source,omitempty" protobuf:"bytes,2,name=source"`
}

// ClaimSource describes a reference to a ResourceClaim.
//
// Exactly one of these fields should be set.  Consumers of this type must
// treat an empty object as if it has an unknown value.
#[derive(Serialize, Deserialize, Debug)]
pub struct ClaimSource {
    // ResourceClaimName is the name of a ResourceClaim object in the same
	// namespace as this pod.
	resourceClaimName: String, // `json:"resourceClaimName,omitempty" protobuf:"bytes,1,opt,name=resourceClaimName"`

	// ResourceClaimTemplateName is the name of a ResourceClaimTemplate
	// object in the same namespace as this pod.
	//
	// The template will be used to create a new ResourceClaim, which will
	// be bound to this pod. When this pod is deleted, the ResourceClaim
	// will also be deleted. The name of the ResourceClaim will be <pod
	// name>-<resource name>, where <resource name> is the
	// PodResourceClaim.Name. Pod validation will reject the pod if the
	// concatenated name is not valid for a ResourceClaim (e.g. too long).
	//
	// An existing ResourceClaim with that name that is not owned by the
	// pod will not be used for the pod to avoid using an unrelated
	// resource by mistake. Scheduling and pod startup are then blocked
	// until the unrelated ResourceClaim is removed.
	//
	// This field is immutable and no changes will be made to the
	// corresponding ResourceClaim by the control plane after creating the
	// ResourceClaim.
	resourceClaimTemplateName: String, // `json:"resourceClaimTemplateName,omitempty" protobuf:"bytes,2,opt,name=resourceClaimTemplateName"`
}

// OSName is the set of OS'es that can be used in OS.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum OSName {
    #[serde(rename = "linux")]
    Linux,
	#[serde(rename = "windows")]
    Windows,
}

// PodOS defines the OS parameters of a pod.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodOS {
    // Name is the name of the operating system. The currently supported values are linux and windows.
	// Additional value may be defined in future and can be one of:
	// https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
	// Clients should expect to handle additional values and treat unrecognized values in this field as os: null
	name: OSName, // `json:"name" protobuf:"bytes,1,opt,name=name"`
}

// PodSchedulingGate is associated to a Pod to guard its scheduling.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodSchedulingGate {
    // Name of the scheduling gate.
	// Each scheduling gate must have a unique name field.
	name: String, // `json:"name" protobuf:"bytes,1,opt,name=name"`
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum UnsatisfiableConstraintAction {
    // DoNotSchedule instructs the scheduler not to schedule the pod
	// when constraints are not satisfied.
	#[serde(rename = "DoNotSchedule")]
    DoNotSchedule,
	// ScheduleAnyway instructs the scheduler to schedule the pod
	// even if constraints are not satisfied.
	#[serde(rename = "ScheduleAnyway")]
    ScheduleAnyway,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum NodeInclusionPolicy {
    // NodeInclusionPolicyIgnore means ignore this scheduling directive when calculating pod topology spread skew.
	#[serde(rename = "Ignore")]
    NodeInclusionPolicyIgnore,
	// NodeInclusionPolicyHonor means use this scheduling directive when calculating pod topology spread skew.
	#[serde(rename = "Honor")]
    NodeInclusionPolicyHonor,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct TopologySpreadConstraint {
}

pub const DEFAULT_ENABLE_SERVICE_LINKS: bool = true;

// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
// pod's hosts file.
#[derive(Serialize, Deserialize, Debug)]
pub struct HostAlias {
    // IP address of the host file entry.
	ip: String, // `json:"ip,omitempty" protobuf:"bytes,1,opt,name=ip"`
	// Hostnames for the above IP address.
	hostnames: Vec<String>, // `json:"hostnames,omitempty" protobuf:"bytes,2,rep,name=hostnames"`
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum PodFSGroupChangePolicy {
    // FSGroupChangeOnRootMismatch indicates that volume's ownership and permissions will be changed
	// only when permission and ownership of root directory does not match with expected
	// permissions on the volume. This can help shorten the time it takes to change
	// ownership and permissions of a volume.
	#[serde(rename = "OnRootMismatch")]
    FSGroupChangeOnRootMismatch,
	// FSGroupChangeAlways indicates that volume's ownership and permissions
	// should always be changed whenever volume is mounted inside a Pod. This the default
	// behavior.
	#[serde(rename = "Always")]
    FSGroupChangeAlways,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct PodSecurityContext {
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum PodQOSClass {
    // PodQOSGuaranteed is the Guaranteed qos class.
	#[serde(rename = "Guaranteed")]
    PodQOSGuaranteed,
	// PodQOSBurstable is the Burstable qos class.
	#[serde(rename = "Burstable")]
    PodQOSBurstable,
	// PodQOSBestEffort is the BestEffort qos class.
	#[serde(rename = "BestEffort")]
    PodQOSBestEffor,
}

// PodDNSConfig defines the DNS parameters of a pod in addition to
// those generated from DNSPolicy.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodDNSConfig {
    // A list of DNS name server IP addresses.
	// This will be appended to the base nameservers generated from DNSPolicy.
	// Duplicated nameservers will be removed.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	nameservers: Vec<String>, // `json:"nameservers,omitempty" protobuf:"bytes,1,rep,name=nameservers"`
	// A list of DNS search domains for host-name lookup.
	// This will be appended to the base search paths generated from DNSPolicy.
	// Duplicated search paths will be removed.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	searches: Vec<String>, // `json:"searches,omitempty" protobuf:"bytes,2,rep,name=searches"`
	// A list of DNS resolver options.
	// This will be merged with the base options generated from DNSPolicy.
	// Duplicated entries will be removed. Resolution options given in Options
	// will override those that appear in the base DNSPolicy.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	options: Vec<PodDNSConfigOption>, // `json:"options,omitempty" protobuf:"bytes,3,rep,name=options"`
}

// PodDNSConfigOption defines DNS resolver options of a pod.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodDNSConfigOption {
    // Required.
    name: String, // `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
	// +optional
	value: String, // `json:"value,omitempty" protobuf:"bytes,2,opt,name=value"`
}

// IP address information for entries in the (plural) PodIPs field.
// Each entry includes:
//
//	IP: An IP address allocated to the pod. Routable at least within the cluster.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodIP {
    // ip is an IP address (IPv4 or IPv6) assigned to the pod
	IP: String, // `json:"ip,omitempty" protobuf:"bytes,1,opt,name=ip"`
}

pub type EphemeralContainer = Container;

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system, especially if the node that hosts the pod cannot contact the control
// plane.
#[derive(Serialize, Deserialize, Debug)]
pub struct PodStatus {
	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
	// The conditions array, the reason and message fields, and the individual container status
	// arrays contain more detail about the pod's status.
	// There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
	// container images has not been created. This includes time before being scheduled as
	// well as time spent downloading images over the network, which could take a while.
	// Running: The pod has been bound to a node, and all of the containers have been created.
	// At least one container is still running, or is in the process of starting or restarting.
	// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
	// Failed: All containers in the pod have terminated, and at least one container has
	// terminated in failure. The container either exited with non-zero status or was terminated
	// by the system.
	// Unknown: For some reason the state of the pod could not be obtained, typically due to an
	// error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	// +optional
	#[serde(default)]
	phase: PodPhase, // `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PodPhase"`
	// Current service state of pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	conditions: Vec<PodCondition>, // `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,2,rep,name=conditions"`
	// A human readable message indicating details about why the pod is in this condition.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	message: String, // `json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`
	// A brief CamelCase message indicating details about why the pod is in this state.
	// e.g. 'Evicted'
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	reason: String, // `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`
	// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
	// scheduled right away as preemption victims receive their graceful termination periods.
	// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
	// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
	// give the resources on this node to a higher priority pod that is created after preemption.
	// As a result, this field may be different than PodSpec.nodeName when the pod is
	// scheduled.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	nominatedNodeName: String, // `json:"nominatedNodeName,omitempty" protobuf:"bytes,11,opt,name=nominatedNodeName"`

	// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	hostIP: String, // `json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`
	// IP address allocated to the pod. Routable at least within the cluster.
	// Empty if not yet allocated.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	podIP: String, // `json:"podIP,omitempty" protobuf:"bytes,6,opt,name=podIP"`

	// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
	// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
	// is empty if no IPs have been allocated yet.
	// +optional
	// +patchStrategy=merge
	// +patchMergeKey=ip
	podIPs: Vec<PodIP>, // `json:"podIPs,omitempty" protobuf:"bytes,12,rep,name=podIPs" patchStrategy:"merge" patchMergeKey:"ip"`

	// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
	// This is before the Kubelet pulled the container image(s) for the pod.
	// +optional
	startTime: SystemTime, // `json:"startTime,omitempty" protobuf:"bytes,7,opt,name=startTime"`

	// The list has one entry per init container in the manifest. The most recent successful
	// init container will have ready = true, the most recently started container will have
	// startTime set.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	initContainerStatuses: Vec<ContainerStatus>, // `json:"initContainerStatuses,omitempty" protobuf:"bytes,10,rep,name=initContainerStatuses"`

	// The list has one entry per container in the manifest.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	containerStatuses: Vec<ContainerStatus>, // `json:"containerStatuses,omitempty" protobuf:"bytes,8,rep,name=containerStatuses"`
	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	qosClass: Option<PodQOSClass>, // `json:"qosClass,omitempty" protobuf:"bytes,9,rep,name=qosClass"`
	// Status for any ephemeral containers that have run in this pod.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	ephemeralContainerStatuses: Vec<ContainerStatus>, // `json:"ephemeralContainerStatuses,omitempty" protobuf:"bytes,13,rep,name=ephemeralContainerStatuses"`
}


// NodeSpec describes the attributes that a node is created with.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeSpec {
	// PodCIDR represents the pod IP range assigned to the node.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	podCIDR: String,// `json:"podCIDR,omitempty" protobuf:"bytes,1,opt,name=podCIDR"`

	// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
	// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
	// each of IPv4 and IPv6.
	// +optional
	// +patchStrategy=merge
	podCIDRs: Vec<String>, // `json:"podCIDRs,omitempty" protobuf:"bytes,7,opt,name=podCIDRs" patchStrategy:"merge"`

	// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	providerID: String, // `json:"providerID,omitempty" protobuf:"bytes,3,opt,name=providerID"`
	// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
	// +optional
	#[serde(default)]
	unschedulable: bool, // `json:"unschedulable,omitempty" protobuf:"varint,4,opt,name=unschedulable"`
	// If specified, the node's taints.
	// +optional
	#[serde(default, skip_serializing_if = "Vec::is_empty")]
	taints: Vec<Taint>, // `json:"taints,omitempty" protobuf:"bytes,5,opt,name=taints"`

	// Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed.
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	configSource: Option<NodeConfigSource>, // `json:"configSource,omitempty" protobuf:"bytes,6,opt,name=configSource"`
}

// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
// This API is deprecated since 1.22
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeConfigSource {
	// For historical context, regarding the below kind, apiVersion, and configMapRef deprecation tags:
	// 1. kind/apiVersion were used by the kubelet to persist this struct to disk (they had no protobuf tags)
	// 2. configMapRef and proto tag 1 were used by the API to refer to a configmap,
	//    but used a generic ObjectReference type that didn't really have the fields we needed
	// All uses/persistence of the NodeConfigSource struct prior to 1.11 were gated by alpha feature flags,
	// so there was no persisted data for these fields that needed to be migrated/handled.

	// +k8s:deprecated=kind
	// +k8s:deprecated=apiVersion
	// +k8s:deprecated=configMapRef,protobuf=1

	// ConfigMap is a reference to a Node's ConfigMap
	configMap: Option<ConfigMapNodeConfigSource>, // `json:"configMap,omitempty" protobuf:"bytes,2,opt,name=configMap"`
}

// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
// This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration

#[derive(Serialize, Deserialize, Debug)]
pub struct ConfigMapNodeConfigSource {
	// Namespace is the metadata.namespace of the referenced ConfigMap.
	// This field is required in all cases.
	namespace: String, // `json:"namespace" protobuf:"bytes,1,opt,name=namespace"`

	// Name is the metadata.name of the referenced ConfigMap.
	// This field is required in all cases.
	name: String, // `json:"name" protobuf:"bytes,2,opt,name=name"`

	// UID is the metadata.UID of the referenced ConfigMap.
	// This field is forbidden in Node.Spec, and required in Node.Status.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	uid: String, // `json:"uid,omitempty" protobuf:"bytes,3,opt,name=uid"`

	// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
	// This field is forbidden in Node.Spec, and required in Node.Status.
	// +optional
	#[serde(default, skip_serializing_if = "String::is_empty")]
	resourceVersion: String, // `json:"resourceVersion,omitempty" protobuf:"bytes,4,opt,name=resourceVersion"`

	// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
	// This field is required in all cases.
	kubeletConfigKey: String, // `json:"kubeletConfigKey" protobuf:"bytes,5,opt,name=kubeletConfigKey"`
}

// DaemonEndpoint contains information about a single Daemon endpoint.
#[derive(Serialize, Deserialize, Debug)]
pub struct DaemonEndpoint {
	/*
		The port tag was not properly in quotes in earlier releases, so it must be
		uppercased for backwards compat (since it was falling back to var name of
		'Port').
	*/

	// Port number of the given endpoint.
	Port: i32, // `json:"Port" protobuf:"varint,1,opt,name=Port"`
}

// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeDaemonEndpoints {
	// Endpoint on which Kubelet is listening.
	// +optional
	kubeletEndpoint: DaemonEndpoint, // `json:"kubeletEndpoint,omitempty" protobuf:"bytes,1,opt,name=kubeletEndpoint"
}

// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeSystemInfo {
	// MachineID reported by the node. For unique machine identification
	// in the cluster this field is preferred. Learn more from man(5)
	// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
	machineID: String, // `json:"machineID" protobuf:"bytes,1,opt,name=machineID"`
	// SystemUUID reported by the node. For unique machine identification
	// MachineID is preferred. This field is specific to Red Hat hosts
	// https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
	systemUUID: String, // `json:"systemUUID" protobuf:"bytes,2,opt,name=systemUUID"`
	// Boot ID reported by the node.
	bootID: String, // `json:"bootID" protobuf:"bytes,3,opt,name=bootID"`
	// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
	kernelVersion: String, // `json:"kernelVersion" protobuf:"bytes,4,opt,name=kernelVersion"`
	// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
	osImage: String, // `json:"osImage" protobuf:"bytes,5,opt,name=osImage"`
	// ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
	containerRuntimeVersion: String, // `json:"containerRuntimeVersion" protobuf:"bytes,6,opt,name=containerRuntimeVersion"`
	// Kubelet Version reported by the node.
	kubeletVersion: String, // `json:"kubeletVersion" protobuf:"bytes,7,opt,name=kubeletVersion"`
	// KubeProxy Version reported by the node.
	kubeProxyVersion: String, // `json:"kubeProxyVersion" protobuf:"bytes,8,opt,name=kubeProxyVersion"`
	// The Operating System reported by the node
	operatingSystem: String, // `json:"operatingSystem" protobuf:"bytes,9,opt,name=operatingSystem"`
	// The Architecture reported by the node
	architecture: String, // `json:"architecture" protobuf:"bytes,10,opt,name=architecture"`
}

// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeConfigStatus {
	// Assigned reports the checkpointed config the node will try to use.
	// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
	// config payload to local disk, along with a record indicating intended
	// config. The node refers to this record to choose its config checkpoint, and
	// reports this record in Assigned. Assigned only updates in the status after
	// the record has been checkpointed to disk. When the Kubelet is restarted,
	// it tries to make the Assigned config the Active config by loading and
	// validating the checkpointed payload identified by Assigned.
	// +optional
	assigned: Option<NodeConfigSource>, // `json:"assigned,omitempty" protobuf:"bytes,1,opt,name=assigned"`
	// Active reports the checkpointed config the node is actively using.
	// Active will represent either the current version of the Assigned config,
	// or the current LastKnownGood config, depending on whether attempting to use the
	// Assigned config results in an error.
	// +optional
	active: Option<NodeConfigSource>, // `json:"active,omitempty" protobuf:"bytes,2,opt,name=active"`
	// LastKnownGood reports the checkpointed config the node will fall back to
	// when it encounters an error attempting to use the Assigned config.
	// The Assigned config becomes the LastKnownGood config when the node determines
	// that the Assigned config is stable and correct.
	// This is currently implemented as a 10-minute soak period starting when the local
	// record of Assigned config is updated. If the Assigned config is Active at the end
	// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
	// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
	// because the local default config is always assumed good.
	// You should not make assumptions about the node's method of determining config stability
	// and correctness, as this may change or become configurable in the future.
	// +optional
	lastKnownGood: Option<NodeConfigSource>, // `json:"lastKnownGood,omitempty" protobuf:"bytes,3,opt,name=lastKnownGood"`
	// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
	// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
	// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
	// to load or validate the Assigned config, etc.
	// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
	// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
	// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
	// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
	// by fixing the config assigned in Spec.ConfigSource.
	// You can find additional information for debugging by searching the error message in the Kubelet log.
	// Error is a human-readable description of the error state; machines can check whether or not Error
	// is empty, but should not rely on the stability of the Error text across Kubelet versions.
	// +optional
	error: String, // `json:"error,omitempty" protobuf:"bytes,4,opt,name=error"`
}

// NodeStatus is information about the current status of a node.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeStatus {
	// Capacity represents the total resources of a node.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
	// +optional
	capacity: ResourceList, // `json:"capacity,omitempty" protobuf:"bytes,1,rep,name=capacity,casttype=ResourceList,castkey=ResourceName"`
	// Allocatable represents the resources of a node that are available for scheduling.
	// Defaults to Capacity.
	// +optional
	allocatable: ResourceList, // `json:"allocatable,omitempty" protobuf:"bytes,2,rep,name=allocatable,casttype=ResourceList,castkey=ResourceName"`
	// NodePhase is the recently observed lifecycle phase of the node.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
	// The field is never populated, and now is deprecated.
	// +optional
	phase: NodePhase, // `json:"phase,omitempty" protobuf:"bytes,3,opt,name=phase,casttype=NodePhase"`
	// Conditions is an array of current observed node conditions.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	conditions: Vec<NodeCondition>, // `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,4,rep,name=conditions"`
	// List of addresses reachable to the node.
	// Queried from cloud provider, if available.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
	// Note: This field is declared as mergeable, but the merge key is not sufficiently
	// unique, which can cause data corruption when it is merged. Callers should instead
	// use a full-replacement patch. See https://pr.k8s.io/79391 for an example.
	// Consumers should assume that addresses can change during the
	// lifetime of a Node. However, there are some exceptions where this may not
	// be possible, such as Pods that inherit a Node's address in its own status or
	// consumers of the downward API (status.hostIP).
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	addresses: Vec<NodeAddress>, // `json:"addresses,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,5,rep,name=addresses"`
	// Endpoints of daemons running on the Node.
	// +optional
	daemonEndpoints: NodeDaemonEndpoints, // `json:"daemonEndpoints,omitempty" protobuf:"bytes,6,opt,name=daemonEndpoints"`
	// Set of ids/uuids to uniquely identify the node.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
	// +optional
	nodeInfo: NodeSystemInfo, // `json:"nodeInfo,omitempty" protobuf:"bytes,7,opt,name=nodeInfo"`
	// List of container images on this node
	// +optional
	images: Vec<ContainerImage>, // `json:"images,omitempty" protobuf:"bytes,8,rep,name=images"`
	// List of attachable volumes in use (mounted) by the node.
	// +optional
	//volumesInUse: Vec<UniqueVolumeName>, // `json:"volumesInUse,omitempty" protobuf:"bytes,9,rep,name=volumesInUse"`
	// List of volumes that are attached to the node.
	// +optional
	//volumesAttached: Vec<AttachedVolume>, // `json:"volumesAttached,omitempty" protobuf:"bytes,10,rep,name=volumesAttached"`
	// Status of the config assigned to the node via the dynamic Kubelet config feature.
	// +optional
	config: Option<NodeConfigStatus>, // `json:"config,omitempty" protobuf:"bytes,11,opt,name=config"`
}


#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum NodeAddressType {
	// NodeHostName identifies a name of the node. Although every node can be assumed
	// to have a NodeAddress of this type, its exact syntax and semantics are not
	// defined, and are not consistent between different clusters.
	#[serde(rename = "Hostname")]
    NodeHostName,

	// NodeInternalIP identifies an IP address which is assigned to one of the node's
	// network interfaces. Every node should have at least one address of this type.
	//
	// An internal IP is normally expected to be reachable from every other node, but
	// may not be visible to hosts outside the cluster. By default it is assumed that
	// kube-apiserver can reach node internal IPs, though it is possible to configure
	// clusters where this is not the case.
	//
	// NodeInternalIP is the default type of node IP, and does not necessarily imply
	// that the IP is ONLY reachable internally. If a node has multiple internal IPs,
	// no specific semantics are assigned to the additional IPs.
	#[serde(rename = "InternalIP")]
    NodeInternalIP,

	// NodeExternalIP identifies an IP address which is, in some way, intended to be
	// more usable from outside the cluster then an internal IP, though no specific
	// semantics are defined. It may be a globally routable IP, though it is not
	// required to be.
	//
	// External IPs may be assigned directly to an interface on the node, like a
	// NodeInternalIP, or alternatively, packets sent to the external IP may be NAT'ed
	// to an internal node IP rather than being delivered directly (making the IP less
	// efficient for node-to-node traffic than a NodeInternalIP).
	#[serde(rename = "ExternalIP")]
    NodeExternalIP,

	// NodeInternalDNS identifies a DNS name which resolves to an IP address which has
	// the characteristics of a NodeInternalIP. The IP it resolves to may or may not
	// be a listed NodeInternalIP address.
	#[serde(rename = "InternalDNS")]
    NodeInternalDNS,

	// NodeExternalDNS identifies a DNS name which resolves to an IP address which has
	// the characteristics of a NodeExternalIP. The IP it resolves to may or may not
	// be a listed NodeExternalIP address.
	#[serde(rename = "ExternalDNS")]
    NodeExternalDNS,
}

// NodeAddress contains information for the node's address.
#[derive(Serialize, Deserialize, Debug)]
pub struct NodeAddress {
	// Node address type, one of Hostname, ExternalIP or InternalIP.
	#[serde(rename = "type")]
    type_: NodeAddressType, // `json:"type" protobuf:"bytes,1,opt,name=type,casttype=NodeAddressType"`
	// The node address.
	address: String, // `json:"address" protobuf:"bytes,2,opt,name=address"`
}


// Resource names must be not more than 63 characters, consisting of upper- or lower-case alphanumeric characters,
// with the -, _, and . characters allowed anywhere, except the first or last character.
// The default convention, matching that for annotations, is to use lower-case names, with dashes, rather than
// camel case, separating compound words.
// Fully-qualified resource typenames are constructed from a DNS-style subdomain, followed by a slash `/` and a name.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum ResourceName {
    // CPU, in cores. (500m = .5 cores)
	#[serde(rename = "cpu")]
    ResourceCPU,
	// Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
	#[serde(rename = "memory")]
    ResourceMemory,
	// Volume size, in bytes (e,g. 5Gi = 5GiB = 5 * 1024 * 1024 * 1024)
	#[serde(rename = "storage")]
    ResourceStorage,
	// Local ephemeral storage, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
	// The resource name for ResourceEphemeralStorage is alpha and it can change across releases.
	#[serde(rename = "ephemeral-storage")]
    ResourceEphemeralStorage,
}

// Describe a container image
#[derive(Serialize, Deserialize, Debug)]
pub struct ContainerImage {
	// Names by which this image is known.
	// e.g. ["kubernetes.example/hyperkube:v1.0.7", "cloud-vendor.registry.example/cloud-vendor/hyperkube:v1.0.7"]
	// +optional
	names: Vec<String>, // `json:"names" protobuf:"bytes,1,rep,name=names"`
	// The size of the image in bytes.
	// +optional
	sizeBytes: i64, // `json:"sizeBytes,omitempty" protobuf:"varint,2,opt,name=sizeBytes"`
}

// These are the valid phases of node.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum NodePhase {
	// NodePending means the node has been created/added by the system, but not configured.
	#[serde(rename = "Pending")]
    NodePending,
	// NodeRunning means the node has been configured and has Kubernetes components running.
	#[serde(rename = "Running")]
    NodeRunning,
	// NodeTerminated means the node has been removed from the cluster.
	#[serde(rename = "Terminated")]
    NodeTerminated,
}

// These are valid but not exhaustive conditions of node. A cloud provider may set a condition not listed here.
// The built-in set of conditions are:
// NodeReachable, NodeLive, NodeReady, NodeSchedulable, NodeRunnable.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum NodeConditionType {
	// NodeReady means kubelet is healthy and ready to accept pods.
	#[serde(rename = "Ready")]
    NodeReady,
	// NodeMemoryPressure means the kubelet is under pressure due to insufficient available memory.
	#[serde(rename = "MemoryPressure")]
    NodeMemoryPressure,
	// NodeDiskPressure means the kubelet is under pressure due to insufficient available disk.
	#[serde(rename = "DiskPressure")]
    NodeDiskPressure,
	// NodePIDPressure means the kubelet is under pressure due to insufficient available PID.
	#[serde(rename = "PIDPressure")]
    NodePIDPressure,
	// NodeNetworkUnavailable means that network for the node is not correctly configured.
	#[serde(rename = "NetworkUnavailable")]
    NodeNetworkUnavailable,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NodeCondition {
	// Type of node condition.
	#[serde(rename = "type")]
    type_: NodeConditionType, // `json:"type" protobuf:"bytes,1,opt,name=type,casttype=NodeConditionType"`
	// Status of the condition, one of True, False, Unknown.
	status: ConditionStatus, // `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
	// Last time we got an update on a given condition.
	// +optional
	lastHeartbeatTime: SystemTime, // `json:"lastHeartbeatTime,omitempty" protobuf:"bytes,3,opt,name=lastHeartbeatTime"`
	// Last time the condition transit from one status to another.
	// +optional
	lastTransitionTime: SystemTime, // `json:"lastTransitionTime,omitempty" protobuf:"bytes,4,opt,name=lastTransitionTime"`
	// (brief) reason for the condition's last transition.
	// +optional
	reason: String, // `json:"reason,omitempty" protobuf:"bytes,5,opt,name=reason"`
	// Human readable message indicating details about last transition.
	// +optional
	message: String, // `json:"message,omitempty" protobuf:"bytes,6,opt,name=message"`
}


pub type ResourceList = BTreeMap<ResourceName, Quantity>;


#[derive(Debug)]
pub struct Meta {
    pub kind: String,
    pub namespace: String,
    pub name: String,
    pub lables: Labels,
    pub annotations: Labels,
    
    // revision number set by etcd
    pub reversion: i64,
}

// Node is a worker node in Kubernetes.
// Each node will have a unique identifier in the cache (i.e. in etcd).

#[derive(Debug)]
pub struct Node {
	meta: Meta, 

	content: NodeContent,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct NodeContent {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	//metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`

	// Spec defines the behavior of a node.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec: NodeSpec, // `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`

	// Most recently observed status of the node.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status: NodeStatus, // `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
}

pub struct Pod {
	meta: Meta,
	context: PodContent,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct PodContent {
	spec: PodSpec,
	status: PodStatus,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct V1Node {
	#[serde(flatten)]
	typeMeta: TypeMeta, // `json:",inline"`
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	#[serde(default, flatten, skip_serializing_if = "Option::is_none")]
	objMeta: Option<ObjectMeta>, // `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`

	// Spec defines the behavior of a node.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	spec: Option<NodeSpec>, // `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`

	// Most recently observed status of the node.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	#[serde(default, skip_serializing_if = "Option::is_none")]
	status: Option<NodeStatus>, // `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
}


// Pod is a collection of containers that can run on a host. This resource is created
// by clients and scheduled onto hosts.#[derive(Serialize, Deserialize, Debug)]
#[derive(Serialize, Deserialize, Debug)]
pub struct V1Pod {
	#[serde(flatten)]
	pub typeMeta: TypeMeta, // `json:",inline"`
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	//#[serde(default)]
	pub objMeta: ObjectMeta, // `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`

	// Specification of the desired behavior of the pod.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	//#[serde(default)]
	pub spec: PodSpec, // `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`

	// Most recently observed status of the pod.
	// This data may not be up to date.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	//#[serde(default)]
	pub status: PodStatus, // `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
}

#[derive(Serialize, Deserialize, Debug)]
pub struct ConfigMap {
	// Data contains the configuration data.
	// Each key must consist of alphanumeric characters, '-', '_' or '.'.
	// Values with non-UTF-8 byte sequences must use the BinaryData field.
	// The keys stored in Data must not overlap with the keys in
	// the BinaryData field, this is enforced during validation process.
	// +optional
	#[serde(default)]
	pub Data: BTreeMap<String, String>, // `json:"data,omitempty" protobuf:"bytes,2,rep,name=data"`

	// BinaryData contains the binary data.
	// Each key must consist of alphanumeric characters, '-', '_' or '.'.
	// BinaryData can contain byte sequences that are not in the UTF-8 range.
	// The keys stored in BinaryData must not overlap with the ones in
	// the Data field, this is enforced during validation process.
	// Using this field will require 1.10+ apiserver and
	// kubelet.
	// +optional
	#[serde(default)]
	pub binaryData: BTreeMap<String, Vec<u8>>, // `json:"binaryData,omitempty" protobuf:"bytes,3,rep,name=binaryData"`
}

// Secret holds secret data of a certain type. The total bytes of the values in
// the Data field must be less than MaxSecretSize bytes.
pub struct Secret {
	//pub metav1.TypeMeta `json:",inline"`
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	//pub metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`

	// Immutable, if set to true, ensures that data stored in the Secret cannot
	// be updated (only object metadata can be modified).
	// If not set to true, the field can be modified at any time.
	// Defaulted to nil.
	// +optional
	pub Immutable: bool, // `json:"immutable,omitempty" protobuf:"varint,5,opt,name=immutable"`

	// Data contains the secret data. Each key must consist of alphanumeric
	// characters, '-', '_' or '.'. The serialized form of the secret data is a
	// base64 encoded string, representing the arbitrary (possibly non-string)
	// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
	// +optional
	pub Data: BTreeMap<String, Vec<u8>>, // `json:"data,omitempty" protobuf:"bytes,2,rep,name=data"`

	// stringData allows specifying non-binary secret data in string form.
	// It is provided as a write-only input field for convenience.
	// All keys and values are merged into the data field on write, overwriting any existing values.
	// The stringData field is never output when reading from the API.
	// +k8s:conversion-gen=false
	// +optional
	pub StringData: BTreeMap<String, String>, // `json:"stringData,omitempty" protobuf:"bytes,4,rep,name=stringData"`

	// Used to facilitate programmatic handling of secret data.
	// More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
	// +optional
	pub Type: SecretType, // `json:"type,omitempty" protobuf:"bytes,3,opt,name=type,casttype=SecretType"`
}

pub type SecretType = String;

	// SecretTypeOpaque is the default. Arbitrary user-defined data
pub const SecretTypeOpaque: &str = "Opaque";

// SecretTypeServiceAccountToken contains a token that identifies a service account to the API
//
// Required fields:
// - Secret.Annotations["kubernetes.io/service-account.name"] - the name of the ServiceAccount the token identifies
// - Secret.Annotations["kubernetes.io/service-account.uid"] - the UID of the ServiceAccount the token identifies
// - Secret.Data["token"] - a token that identifies the service account to the API
pub const SecretTypeServiceAccountToken: &str = "kubernetes.io/service-account-token";

// ServiceAccountNameKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
pub const ServiceAccountNameKey: &str = "kubernetes.io/service-account.name";
// ServiceAccountUIDKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
pub const ServiceAccountUIDKey: &str = "kubernetes.io/service-account.uid";
// ServiceAccountTokenKey is the key of the required data for SecretTypeServiceAccountToken secrets
pub const ServiceAccountTokenKey: &str = "token";
// ServiceAccountKubeconfigKey is the key of the optional kubeconfig data for SecretTypeServiceAccountToken secrets
pub const ServiceAccountKubeconfigKey: &str = "kubernetes.kubeconfig";
// ServiceAccountRootCAKey is the key of the optional root certificate authority for SecretTypeServiceAccountToken secrets
pub const ServiceAccountRootCAKey: &str = "ca.crt";
// ServiceAccountNamespaceKey is the key of the optional namespace to use as the default for namespaced API calls
pub const ServiceAccountNamespaceKey: &str = "namespace";

// SecretTypeDockercfg contains a dockercfg file that follows the same format rules as ~/.dockercfg
//
// Required fields:
// - Secret.Data[".dockercfg"] - a serialized ~/.dockercfg file
pub const SecretTypeDockercfg: &str = "kubernetes.io/dockercfg";

// DockerConfigKey is the key of the required data for SecretTypeDockercfg secrets
pub const DockerConfigKey: &str = ".dockercfg";

// SecretTypeDockerConfigJson contains a dockercfg file that follows the same format rules as ~/.docker/config.json
//
// Required fields:
// - Secret.Data[".dockerconfigjson"] - a serialized ~/.docker/config.json file
pub const SecretTypeDockerConfigJson: &str = "kubernetes.io/dockerconfigjson";

// DockerConfigJsonKey is the key of the required data for SecretTypeDockerConfigJson secrets
pub const DockerConfigJsonKey: &str = ".dockerconfigjson";

// SecretTypeBasicAuth contains data needed for basic authentication.
//
// Required at least one of fields:
// - Secret.Data["username"] - username used for authentication
// - Secret.Data["password"] - password or token needed for authentication
pub const SecretTypeBasicAuth: &str = "kubernetes.io/basic-auth";

// BasicAuthUsernameKey is the key of the username for SecretTypeBasicAuth secrets
pub const BasicAuthUsernameKey: &str = "username";
// BasicAuthPasswordKey is the key of the password or token for SecretTypeBasicAuth secrets
pub const asicAuthPasswordKey: &str = "password";

// SecretTypeSSHAuth contains data needed for SSH authetication.
//
// Required field:
// - Secret.Data["ssh-privatekey"] - private SSH key needed for authentication
pub const SecretTypeSSHAuth: &str = "kubernetes.io/ssh-auth";

// SSHAuthPrivateKey is the key of the required SSH private key for SecretTypeSSHAuth secrets
pub const SSHAuthPrivateKey: &str = "ssh-privatekey";
// SecretTypeTLS contains information about a TLS client or server secret. It
// is primarily used with TLS termination of the Ingress resource, but may be
// used in other types.
//
// Required fields:
// - Secret.Data["tls.key"] - TLS private key.
//   Secret.Data["tls.crt"] - TLS certificate.
// TODO: Consider supporting different formats, specifying CA/destinationCA.
pub const SecretTypeTLS: &str = "kubernetes.io/tls";

// TLSCertKey is the key for tls certificates in a TLS secret.
pub const TLSCertKey: &str = "tls.crt";
// TLSPrivateKeyKey is the key for the private key field in a TLS secret.
pub const TLSPrivateKeyKey: &str = "tls.key";
// SecretTypeBootstrapToken is used during the automated bootstrap process (first
// implemented by kubeadm). It stores tokens that are used to sign well known
// ConfigMaps. They are used for authn.
pub const SecretTypeBootstrapToken: &str = "bootstrap.kubernetes.io/token";
