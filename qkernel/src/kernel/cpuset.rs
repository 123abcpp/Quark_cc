// Copyright (c) 2021 QuarkSoft LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use alloc::vec::Vec;

pub const BITS_PER_BYTE: usize = 8;
pub const BYTES_PER_LONG: usize = 8; // only for 64-bit architectures

pub fn CPUSetSize(num: usize) -> usize {
    let bytes = (num + BITS_PER_BYTE - 1) / BITS_PER_BYTE;
    let longs = (bytes + BYTES_PER_LONG - 1) / BYTES_PER_LONG;
    return longs * BYTES_PER_LONG
}

const ONES: [u8; 256] = [
    0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
    0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
];

#[derive(Default, Debug)]
pub struct CPUSet(pub Vec<u8>);

impl CPUSet {
    // NewCPUSet returns a CPUSet for the given number of CPUs which initially
    // contains no CPUs.
    pub fn New(num: usize) -> Self {
        return Self(vec![0; CPUSetSize(num)])
    }

    // NewFullCPUSet returns a CPUSet for the given number of CPUs, all of which
    // are present in the set.
    pub fn NewFullCPUSet(num: usize) -> Self {
        let mut set = Self::New(num);

        for i in 0..num / BITS_PER_BYTE {
            set.0[i] = 0xff;
        }

        let idx = num / BITS_PER_BYTE;

        let rem = num % BITS_PER_BYTE;
        if rem != 0 {
            set.0[idx] = (1 << rem) - 1;
        }

        return set
    }

    // Size returns the size of 'c' in bytes.
    pub fn Size(&self) -> usize {
        return self.0.len()
    }

    // NumCPUs returns how many cpus are set in the CPUSet.
    pub fn NumCPUs(&self) -> usize {
        let mut res = 0;
        for v in &self.0 {
            res += ONES[*v as usize] as usize
        }

        return res
    }

    // Copy returns a copy of the CPUSet.
    pub fn Copy(&self) -> Self {
        let mut dup = Vec::with_capacity(self.0.len());
        for v in &self.0 {
            dup.push(*v)
        }

        return Self(dup)
    }

    // Set sets the bit corresponding to cpu.
    pub fn Set(&mut self, cpu: usize) {
        self.0[cpu / BITS_PER_BYTE] |= 1 << (cpu % BITS_PER_BYTE)
    }

    // ClearAbove clears bits corresponding to cpu and all higher cpus.
    pub fn ClearAbove(&mut self, cpu: usize) {
        let i = cpu / BITS_PER_BYTE;
        if i >= self.0.len() {
            return;
        }

        self.0[i] &= !(0xff << (cpu % BITS_PER_BYTE));

        for v in i + 1..self.0.len() {
            self.0[v] = 0;
        }
    }

    // ForEachCPU iterates over the CPUSet and calls fn with the cpu index if
    // it's set.
    pub fn ForEachCPU(&self, mut f: impl FnMut(usize)) {
        for i in 0..self.0.len() * BITS_PER_BYTE {
            let bit = 1 << (i & (BITS_PER_BYTE - 1));
            if (self.0[i / BITS_PER_BYTE] as usize) & bit == bit {
                f(i)
            }
        }
    }
}